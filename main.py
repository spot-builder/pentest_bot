import datetime
from aiocsv import AsyncWriter
from aiogram import Bot, Dispatcher, executor, types
import logging
import os
import hashlib
from aiogram.dispatcher import FSMContext
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher.filters import Text
from fuzzer import run
from classes import *
import nmap
import socket
from multiprocessing import Manager
import threading
import requests
import aiofiles
from Wappalyzer import WebPage, Wappalyzer
import dns.resolver
import whois

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(name)s - %(message)s")
storage = MemoryStorage()
bot = Bot(os.getenv("BOT_TOKEN"))
dp = Dispatcher(bot=bot, storage=storage)


@dp.message_handler(state='*', commands='отмена')
@dp.message_handler(Text(equals='отмена', ignore_case=True), state='*')
async def cancel_handler(message: types.Message, state: FSMContext):
    current_state = await state.get_state()
    logging.info('Cancelling state %r', current_state)
    await message.answer("Отменено")
    await state.finish()
    return


@dp.message_handler(commands=["help", "start"])
async def help_info(message: types.Message):
    await message.answer("/ports - проверка открытых портов, а также информация об OS\n"
                         "/fuzzer - поиск скрытых каталогов и файлов\n"
                         "/web_info - поиск интересной информации о сайте\n"
                         "/vuln_info - поиск уязвимостей\n"
                         "/md5 - MD5 хэширование и взлом MD5-хэша\n"
                         "/dnsr - DNS reconnaissance(whois also)")


@dp.message_handler(commands='vuln_info')
async def web_info(message: types.Message):
    await VulnInfo.url.set()
    await message.answer("Введите URL(без указания протокола) или IP")


@dp.message_handler(state=VulnInfo.url)
async def web_info(message: types.Message, state: FSMContext):
    async with state.proxy() as data:
        data['address'] = message.text
    try:
        host = socket.gethostbyname(data['address'])
        scripts = ["http-csrf", "http-stored-xss", "http-dombased-xss", "http-git", "http-xssed"]
        await message.answer("Собираем информацию об уязвимостях на открытых портах")
        data_dict = Manager().dict()

        def callback_n(host, result):
            data_dict[host] = result
            return 0

        nm = nmap.PortScannerAsync()
        nm.scan(data['address'], arguments=f'-n --script={",".join(scripts)}', callback=callback_n)
        while nm.still_scanning():
            pass
        try:
            port_data = data_dict[host]["scan"][host]['tcp']
            await message.answer("Формиурем документ для отправки")
            file_name = f"vuln_info_{data['address']}_{datetime.datetime.now().strftime('%d_%m_%Y_%H_%M')}.csv"
            vuln_data = []
            for port in port_data.keys():
                if port_data[port].get('script'):
                    for script in port_data[port].get('script').keys():
                        vuln_data.append([port, script, port_data[port].get('script').get(script)])
            async with aiofiles.open(file_name, 'w') as file:
                writer = AsyncWriter(file)
                await writer.writerow(
                    [
                        'Port',
                        'Script',
                        'Result'
                    ]
                )
                await writer.writerows(
                    vuln_data
                )
            await bot.send_document(chat_id=message.chat.id, document=open(file_name, 'rb'))
            os.remove(file_name)
            await state.finish()
        except KeyError as ex:
            print(ex)
            await message.answer("Не удалось найти информации")
            await state.finish()
        await state.finish()
    except socket.gaierror:
        await message.answer("Введите адрес без протокола")
        await state.finish()


@dp.message_handler(commands='web_info')
async def web_info(message: types.Message):
    await WebInfo.url.set()
    await message.answer("Введите URL(с указанием протокола) или IP")


@dp.message_handler(state=WebInfo.url)
async def web_info(message: types.Message, state: FSMContext):
    async with state.proxy() as data:
        data['address'] = message.text
    try:
        response = requests.get(data['address'], timeout=3,
                                headers={"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) pentest_bot"})
        data_dict = Manager().dict()
        address = data['address'][data['address'].find("//") + 2:]
        address = address[:address.find('/')] if address.find('/') != -1 else address
        headers_file_name = f"headers_{address}.txt"
        async with aiofiles.open(headers_file_name, 'w') as file:
            for key, value in response.headers.items():
                await file.write(f"{key}: {value}\n")
        await message.answer("Информация о заголовках")
        await bot.send_document(message.chat.id, open(headers_file_name, 'rb'))
        os.remove(headers_file_name)
        try:
            host_name = socket.gethostbyname(address)

            def callback_n(host, result):
                data_dict[host] = result
                return 0

            nm = nmap.PortScannerAsync()
            nm.scan(host_name, arguments=f'-n --script=http-enum', callback=callback_n)
            while nm.still_scanning():
                pass
            port_data = data_dict.get(host_name)['scan'][host_name]['tcp']
            info = ''
            webpage = WebPage.new_from_url(data['address'])
            tech_info_set = Wappalyzer.latest().analyze(webpage)
            tech_info_str = ''
            for item in tech_info_set:
                tech_info_str += f'{item}\n'
            await message.answer("Информация о технологиях работающих на сайте")
            await message.answer(tech_info_str)
            for port in port_data.keys():
                if port_data[port].get('script'):
                    info += f"Port {port}{port_data[port].get('script').get('http-enum')}\n"
            if info:
                await message.answer("Прочая информация")
                other_info_file_name = f"other_info_{address}.txt"
                async with aiofiles.open(other_info_file_name, 'w') as file:
                    await file.write(info.replace('  ', ''))
                await bot.send_document(message.chat.id, open(other_info_file_name, 'rb'))
                os.remove(other_info_file_name)
            else:
                await message.answer("Не удалось найти полезной информации")
            await state.finish()
        except socket.gaierror:
            await message.answer("Что-то пошло не так")
            await state.finish()
    except requests.exceptions.ConnectionError:
        await message.answer("Хост не работает")
        await state.finish()
    except requests.exceptions.MissingSchema:
        await message.answer("Укажите протокол")
        await state.finish()


@dp.message_handler(commands='ports')
async def portscan(message: types.Message):
    await Ports.address.set()
    await message.answer("Введите URL(без указания протокола) или IP")


@dp.message_handler(state=Ports.address)
async def portscan(message: types.Message, state: FSMContext):
    async with state.proxy() as data:
        data['address'] = message.text
    try:
        socket.gethostbyname(f'{data["address"]}')
        await message.answer("Введите максимальное количество проверяемых портов(Рекомендовано 1000)")
        await Ports.next()
    except socket.gaierror:
        await message.answer("Введите корректный адрес")
        await state.finish()


@dp.message_handler(state=Ports.ports)
async def portscan(message: types.Message, state: FSMContext):
    try:
        max_port = int(message.text)
        await state.update_data(max_port=max_port)
    except ValueError:
        await message.answer("Введите корректное число")
        await state.finish()
    data = await state.get_data()

    ports = []
    ip = socket.gethostbyname(data['address'])

    def scan_port(addr, port):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(0.5)
        try:
            sock.connect((addr, port))
            ports.append(port)
            sock.close()
        except:
            pass

    await message.answer("Собираем информацию о работающих портах...")
    for i in range(data['max_port']):
        th = threading.Thread(target=scan_port, args=(ip, i))
        th.start()
    if ports:
        def callback_p(host, result):
            data_dict[host] = result
            return 0

        data_dict = Manager().dict()
        nm = nmap.PortScannerAsync()
        nm.scan(hosts=ip, ports=','.join(list(map(str, ports))), arguments='--min-rate 1000 -sV -n',
                callback=callback_p)
        nm_iter = 0
        while nm.still_scanning():
            if nm_iter == 1000 or nm_iter == 0:
                await message.answer("Собираем информацию о работающих сервисах на портах...")
            nm_iter += 1
            nm.wait(1)
        port_string = ''
        port_info = data_dict[ip]['scan'][ip]['tcp']
        for i in port_info.keys():
            port_string += f'Порт - {i}\nСтатус - {port_info[i]["state"]}\nСервис - {port_info[i]["name"]}' \
                           f'({port_info[i]["product"]})\n' \
                           f'Версия - {port_info[i]["version"]}\n\n'
        await message.answer("Информация об сервисах")
        await message.answer(port_string)
    else:
        await message.answer("Что-то пошло не так. Попробуйте увеличить количество проверямых портов")
    await state.finish()


@dp.message_handler(commands="md5")
async def md5(message: types.Message):
    await MD5.function.set()
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    buttons = ["Крякнуть", "Хэшировать"]
    keyboard.add(*buttons)
    await message.answer("Выберите одну из функций", reply_markup=keyboard)


@dp.message_handler(state=MD5.function)
async def md5(message: types.Message, state: FSMContext):
    async with state.proxy() as data:
        data['function'] = message.text
    if data['function'] == "Крякнуть":
        await message.answer("Введите хэш")
        await MD5.next()
    elif data['function'] == "Хэшировать":
        await message.answer("Введите текст")
        await MD5.next()
    else:
        await message.answer("Введите корректную функцию")
        await state.finish()


@dp.message_handler(state=MD5.text)
async def md5(message: types.Message, state: FSMContext):
    await state.update_data(text=message.text)
    data = await state.get_data()
    if len(data['text']) == 32 and data['function'] == "Крякнуть":
        await message.answer("Сверяем значения со словарем...", reply_markup=types.ReplyKeyboardRemove())
        password = ''
        with open("/usr/share/wordlists/big.txt", 'rb') as file:
            for word in file:
                word = word.strip()
                h = hashlib.md5(word).hexdigest()
                if h == data['text']:
                    password += word.decode()
                    break
        if password:
            await message.answer(f"Значение крякнутого хэша: <i><strong>{password}\n</strong></i>",
                                 parse_mode=types.ParseMode.HTML)
        else:
            await message.answer("Не удалось крякнуть", reply_markup=types.ReplyKeyboardRemove())
    elif data['function'] == "Хэшировать":
        await message.answer(hashlib.md5(data['text'].encode()).hexdigest(), reply_markup=types.ReplyKeyboardRemove())
    else:
        await message.answer("Введите корректный хэш")
    await state.finish()


@dp.message_handler(commands="dnsr")
async def dnsr(message: types.Message):
    await DNSRecon.address.set()
    await message.answer("Введите адрес цели(без указания протокола)")


@dp.message_handler(state=DNSRecon.address)
async def dnsr(message: types.Message, state: FSMContext):
    async with state.proxy() as data:
        data['address'] = message.text
    try:
        socket.gethostbyname(f'{data["address"]}')
        w = whois.whois(data['address'])
        whois_file_name = f"whois_{data['address']}.txt"
        async with aiofiles.open(whois_file_name, 'w') as file:
            await file.write(w.text)
        await message.answer("Whois-информация")
        await bot.send_document(chat_id=message.chat.id, document=open(whois_file_name, 'rb'))
        os.remove(whois_file_name)
        dns_name = ["MX", "A", "A6", "CAA", "CNAME", "NS", "PTR", "SOA", "TXT", "SSHFP", "SRV"]
        dns_file_name = f"dns_{data['address']}.txt"
        for i in dns_name:
            try:
                answ = dns.resolver.resolve(data['address'], i)
                for k in answ:
                    async with aiofiles.open(dns_file_name, 'a') as file:
                        await file.write(f"{i} - {k}\n\n")
            except dns.resolver.NoAnswer:
                pass
            except dns.resolver.LifetimeTimeout:
                await message.answer("Что-то пошло не так")
                await state.finish()
                break
        await message.answer("DNS-информация")
        await bot.send_document(chat_id=message.chat.id, document=open(dns_file_name, 'rb'))
        os.remove(dns_file_name)
        await state.finish()
    except socket.gaierror:
        await message.answer("Введите корректный адрес")
        await state.finish()


@dp.message_handler(commands="fuzzer")
async def fuzzer(message: types.Message):
    await Fuzzer.url.set()
    await message.answer("Введите URL цели с указанием протокола")


@dp.message_handler(state=Fuzzer.url)
async def fuzzer(message: types.Message, state: FSMContext):
    async with state.proxy() as data:
        data['url'] = message.text
    try:
        requests.get(data['url'], headers={"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) pentest_bot"}, timeout=3)
        await message.answer(
            "Введите желаемые расширения файлов через запятую.\nВведите <i><strong>None</strong></i>, "
            "чтобы не использовать расширения", parse_mode=types.ParseMode.HTML)
        await Fuzzer.next()
    except requests.exceptions.ConnectionError:
        await message.answer("Хост не работает")
        await state.finish()
    except requests.exceptions.MissingSchema:
        await message.answer("Укажите протокол")
        await state.finish()


@dp.message_handler(state=Fuzzer.extensions)
async def fuzzer(message: types.Message, state: FSMContext):
    await state.update_data(ex=message.text.split(','))
    data = await state.get_data()
    await message.answer("Собираем информацию о файлах/директориях")
    if data['ex'][0] == "None":
        await message.answer(f"Количество проверяемых директорий: 87650")
    else:
        await message.answer(f"Количество проверяемых директорий: {87650 + (len(data['ex']) * 87650)}")
    try:
        fuzz_data = await run(data['url'], data['ex'])
        await message.answer("Формируем документ для отправки")
        if type(fuzz_data) is str:
            await message.answer(fuzz_data)
            await state.finish()
        elif type(fuzz_data) is list:
            cur_time = datetime.datetime.now().strftime('%d_%m_%Y_%H_%M')
            index_of_backslash = data['url'].find('//')
            file_name = f"fuzzer_{data['url'][index_of_backslash + 2:]}_{cur_time}.csv"
            for i in file_name:
                if i == "/":
                    file_name = file_name.replace(i, '')
            async with aiofiles.open(file_name, 'w') as file:
                writer = AsyncWriter(file)
                await writer.writerow(
                    [
                        'URL',
                        'Status Code',
                        'Content Length'
                    ]
                )
                await writer.writerows(
                    fuzz_data
                )
            await bot.send_document(chat_id=message.chat.id, document=open(file_name, 'rb'))
            os.remove(file_name)
            await state.finish()
    except Exception as ex:
        await message.answer("Что-то пошло не так")
        print(ex)
        await state.finish()


@dp.message_handler()
async def wrong_commands(message: types.Message):
    await message.answer("Для получения информации о существующих командах введите /help")


if __name__ == '__main__':
    executor.start_polling(dp, skip_updates=True)
